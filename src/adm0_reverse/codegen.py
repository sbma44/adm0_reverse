"""
C++ header code generator.

This module generates header-only C++ files containing the embedded quadtree
and lookup functions.
"""

from typing import Dict, Optional
from datetime import datetime, timezone
import textwrap

from .quadtree import QuadTree
from .serialize import serialize_tree, serialize_country_table, bytes_to_cpp_array


def generate_cpp_header(
    tree: QuadTree,
    country_codes: Dict[int, str],
    precision: int,
    oracle_source: str = "unknown",
    namespace: str = "adm0",
    include_iso_lookup: bool = True,
    compress: bool = True,
) -> str:
    """
    Generate a complete C++ header file for country lookup.

    Args:
        tree: The quadtree to embed
        country_codes: Mapping from country_id to ISO code
        precision: Quantization precision
        oracle_source: Description of the oracle data source
        namespace: C++ namespace to use
        include_iso_lookup: Whether to include ISO code lookup
        compress: Whether to compress the tree blob

    Returns:
        Complete C++ header file as string
    """
    # Serialize tree and country table
    tree_blob = serialize_tree(tree, compress=compress)
    country_blob = serialize_country_table(country_codes)

    # Generate the header
    header = _generate_header_template(
        tree_blob=tree_blob,
        country_blob=country_blob,
        precision=precision,
        oracle_source=oracle_source,
        namespace=namespace,
        include_iso_lookup=include_iso_lookup,
        compressed=compress,
        tree_stats={
            "nodes": tree.node_count,
            "leaves": tree.leaf_count,
            "depth": tree.depth,
        },
    )

    return header


def _generate_header_template(
    tree_blob: bytes,
    country_blob: bytes,
    precision: int,
    oracle_source: str,
    namespace: str,
    include_iso_lookup: bool,
    compressed: bool,
    tree_stats: dict,
) -> str:
    """Generate the full header file from template."""

    q = 10 ** precision
    max_ilon = 360 * q
    max_ilat = 180 * q

    build_date = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S UTC")

    # Generate embedded data arrays
    tree_array = bytes_to_cpp_array(tree_blob, "tree_blob")
    country_array = bytes_to_cpp_array(country_blob, "country_table")

    # Indented data arrays
    tree_array_indented = textwrap.indent(tree_array, "    ")
    country_array_indented = textwrap.indent(country_array, "    ")

    header = f'''// Auto-generated country lookup header
// DO NOT EDIT - Generated by adm0-reverse
//
// Precision: {precision} decimal places
// Oracle source: {oracle_source}
// Build date: {build_date}
//
// Tree statistics:
//   Nodes: {tree_stats["nodes"]}
//   Leaves: {tree_stats["leaves"]}
//   Max depth: {tree_stats["depth"]}
//   Blob size: {len(tree_blob)} bytes {"(compressed)" if compressed else "(uncompressed)"}
//   Country count: {len(country_blob) // 4}

#ifndef ADM0_COUNTRY_LOOKUP_P{precision}_HPP
#define ADM0_COUNTRY_LOOKUP_P{precision}_HPP

#include <cstdint>
#include <cstddef>
#include <cmath>
#include <string_view>
'''

    if compressed:
        header += '''
// Requires zlib for decompression
// Link with -lz or include a header-only zlib implementation
#include <zlib.h>
'''

    header += f'''
namespace {namespace} {{

namespace detail {{

// Quantization parameters
static constexpr int PRECISION = {precision};
static constexpr int64_t Q = {q};
static constexpr int64_t MAX_ILON = {max_ilon};
static constexpr int64_t MAX_ILAT = {max_ilat};

// Embedded tree blob
{tree_array_indented}

// Embedded country code table
{country_array_indented}

'''

    if compressed:
        header += '''
// Decompression buffer (lazy initialized)
static unsigned char* decompressed_tree = nullptr;
static size_t decompressed_size = 0;

inline bool ensure_decompressed() {
    if (decompressed_tree != nullptr) return true;

    // Estimate decompressed size (worst case is ~10x compression)
    size_t estimated = tree_blob_size * 20;
    decompressed_tree = new unsigned char[estimated];

    z_stream strm = {};
    strm.next_in = const_cast<unsigned char*>(tree_blob);
    strm.avail_in = tree_blob_size;
    strm.next_out = decompressed_tree;
    strm.avail_out = estimated;

    if (inflateInit(&strm) != Z_OK) {
        delete[] decompressed_tree;
        decompressed_tree = nullptr;
        return false;
    }

    int ret = inflate(&strm, Z_FINISH);
    inflateEnd(&strm);

    if (ret != Z_STREAM_END) {
        delete[] decompressed_tree;
        decompressed_tree = nullptr;
        return false;
    }

    decompressed_size = strm.total_out;
    return true;
}

inline const unsigned char* get_tree_data() {
    ensure_decompressed();
    return decompressed_tree;
}

'''
    else:
        header += '''
inline const unsigned char* get_tree_data() {
    return tree_blob;
}

'''

    header += f'''
// Quantization functions
inline int64_t round_half_away_from_zero(double x) {{
    return static_cast<int64_t>(x >= 0 ? x + 0.5 : x - 0.5);
}}

inline void quantize(double lat, double lon, int64_t& ilat, int64_t& ilon) {{
    // Clamp to valid ranges
    if (lat < -90.0) lat = -90.0;
    if (lat > 90.0) lat = 90.0;
    if (lon < -180.0) lon = -180.0;
    if (lon > 180.0) lon = 180.0;

    // Quantize
    ilon = round_half_away_from_zero((lon + 180.0) * Q);
    ilat = round_half_away_from_zero((lat + 90.0) * Q);

    // Clamp indices
    if (ilon < 0) ilon = 0;
    if (ilon > MAX_ILON) ilon = MAX_ILON;
    if (ilat < 0) ilat = 0;
    if (ilat > MAX_ILAT) ilat = MAX_ILAT;
}}

// Varint decoding
inline uint32_t read_varint(const unsigned char*& ptr) {{
    uint32_t result = 0;
    int shift = 0;
    while (true) {{
        unsigned char b = *ptr++;
        result |= (b & 0x7F) << shift;
        if ((b & 0x80) == 0) break;
        shift += 7;
    }}
    return result;
}}

// Tree traversal
struct Rect {{
    int64_t x0, x1, y0, y1;

    int64_t midX() const {{ return (x0 + x1) / 2; }}
    int64_t midY() const {{ return (y0 + y1) / 2; }}

    // Returns child index: 0=NW, 1=NE, 2=SW, 3=SE
    int childIndex(int64_t x, int64_t y) const {{
        int64_t mx = midX();
        int64_t my = midY();
        if (y > my) {{
            return (x <= mx) ? 0 : 1;  // NW or NE
        }} else {{
            return (x <= mx) ? 2 : 3;  // SW or SE
        }}
    }}

    Rect child(int idx) const {{
        int64_t mx = midX();
        int64_t my = midY();
        switch (idx) {{
            case 0: return {{x0, mx, my + 1, y1}};  // NW
            case 1: return {{mx + 1, x1, my + 1, y1}};  // NE
            case 2: return {{x0, mx, y0, my}};  // SW
            case 3: return {{mx + 1, x1, y0, my}};  // SE
            default: return *this;
        }}
    }}
}};

inline uint16_t lookup_tree(int64_t ilat, int64_t ilon) {{
    const unsigned char* ptr = get_tree_data();
    if (ptr == nullptr) return 0;

    Rect rect{{0, MAX_ILON, 0, MAX_ILAT}};

    while (true) {{
        unsigned char tag = *ptr++;

        if (tag == 0x00) {{
            // Internal node
            unsigned char presence = *ptr++;
            int child_idx = rect.childIndex(ilon, ilat);

            // Skip to the right child
            for (int i = 0; i < child_idx; ++i) {{
                if (presence & (1 << i)) {{
                    // Skip this child's subtree
                    // This requires knowing the size, so we traverse it
                    const unsigned char* skip_ptr = ptr;
                    // Simple approach: recursively count nodes
                    // For efficiency, we'd precompute offsets, but this works
                    int depth = 1;
                    while (depth > 0) {{
                        unsigned char t = *skip_ptr++;
                        if (t == 0x00) {{
                            unsigned char p = *skip_ptr++;
                            for (int j = 0; j < 4; ++j) {{
                                if (p & (1 << j)) depth++;
                            }}
                        }} else {{
                            // Leaf: read varint
                            while (*skip_ptr & 0x80) skip_ptr++;
                            skip_ptr++;
                        }}
                        depth--;
                    }}
                    ptr = skip_ptr;
                }}
            }}

            if (!(presence & (1 << child_idx))) {{
                // Child doesn't exist (shouldn't happen in valid tree)
                return 0;
            }}

            rect = rect.child(child_idx);
        }} else {{
            // Leaf node: tag is 0x01, followed by varint country_id
            return static_cast<uint16_t>(read_varint(ptr));
        }}
    }}
}}

}} // namespace detail

/**
 * Look up the country ID for a given lat/lon coordinate.
 *
 * @param lat Latitude in degrees [-90, 90]
 * @param lon Longitude in degrees [-180, 180]
 * @return Country ID (0 = ocean/unknown)
 */
inline uint16_t country_id(double lat, double lon) {{
    int64_t ilat, ilon;
    detail::quantize(lat, lon, ilat, ilon);
    return detail::lookup_tree(ilat, ilon);
}}

'''

    if include_iso_lookup:
        header += f'''
/**
 * Look up the ISO country code for a given lat/lon coordinate.
 *
 * @param lat Latitude in degrees [-90, 90]
 * @param lon Longitude in degrees [-180, 180]
 * @return ISO country code or empty string if not found
 */
inline std::string_view country_iso(double lat, double lon) {{
    uint16_t id = country_id(lat, lon);
    if (id == 0) return {{}};

    // Read code length from first byte
    const unsigned char* ptr = detail::country_table;
    uint8_t code_len = ptr[0];
    uint16_t count = ptr[1] | (ptr[2] << 8);
    ptr += 3;

    size_t entry_size = 2 + code_len;  // id (2 bytes) + code

    for (uint16_t i = 0; i < count; ++i) {{
        uint16_t entry_id = ptr[0] | (ptr[1] << 8);
        if (entry_id == id) {{
            return std::string_view(reinterpret_cast<const char*>(ptr + 2), code_len);
        }}
        ptr += entry_size;
    }}

    return {{}};
}}

/**
 * Look up the country ID for a given country code.
 *
 * @param iso ISO country code (2 or 3 characters)
 * @return Country ID or 0 if not found
 */
inline uint16_t country_id_from_iso(std::string_view iso) {{
    const unsigned char* ptr = detail::country_table;
    uint8_t code_len = ptr[0];
    uint16_t count = ptr[1] | (ptr[2] << 8);
    ptr += 3;

    if (iso.size() != code_len) return 0;

    size_t entry_size = 2 + code_len;

    for (uint16_t i = 0; i < count; ++i) {{
        bool match = true;
        for (uint8_t j = 0; j < code_len && match; ++j) {{
            if (ptr[2 + j] != static_cast<unsigned char>(iso[j])) match = false;
        }}
        if (match) {{
            return ptr[0] | (ptr[1] << 8);
        }}
        ptr += entry_size;
    }}

    return 0;
}}

'''

    header += f'''
}} // namespace {namespace}

#endif // ADM0_COUNTRY_LOOKUP_P{precision}_HPP
'''

    return header


def generate_test_header(precision: int = 0, namespace: str = "adm0_test") -> str:
    """
    Generate a minimal test header with mock data.

    Useful for testing the C++ decoder without a full oracle.
    """
    from .oracle import MockRectangleOracle
    from .builder import build_quadtree

    oracle = MockRectangleOracle(precision)
    tree, stats = build_quadtree(
        oracle,
        precision=precision,
        sample_k=8,
        brute_force_threshold=1024,
    )

    return generate_cpp_header(
        tree=tree,
        country_codes=oracle.get_country_codes(),
        precision=precision,
        oracle_source="MockRectangleOracle (test data)",
        namespace=namespace,
        include_iso_lookup=True,
        compress=False,  # Simpler for testing
    )
